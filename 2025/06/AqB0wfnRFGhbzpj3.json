{
  "active": false,
  "connections": {
    "Postgres PGVector Store": {
      "main": [
        [
          {
            "node": "search output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres PGVector Store1": {
      "main": [
        [
          {
            "node": "search output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "Postgres PGVector Store",
            "type": "ai_embedding",
            "index": 0
          },
          {
            "node": "Postgres PGVector Store2",
            "type": "ai_embedding",
            "index": 0
          },
          {
            "node": "Postgres PGVector Store1",
            "type": "ai_embedding",
            "index": 0
          },
          {
            "node": "Postgres PGVector Store3",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OTHERS",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ART INPUT",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ORG INPUT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OTHERS": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ORG INPUT": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres PGVector Store2": {
      "main": [
        [
          {
            "node": "org-output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ART INPUT": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres PGVector Store3": {
      "main": [
        [
          {
            "node": "search output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-06-03T04:21:24.189Z",
  "id": "AqB0wfnRFGhbzpj3",
  "meta": null,
  "name": "DbTools",
  "nodes": [
    {
      "parameters": {
        "mode": "load",
        "tableName": "=patchbay_embeddings",
        "prompt": "={{ $json.query }}",
        "options": {
          "distanceStrategy": "cosine",
          "metadata": {
            "metadataValues": [
              {
                "name": "for",
                "value": "={{ $json.for }}"
              },
              {
                "name": "number",
                "value": "={{ $json.book_number }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.1,
      "position": [
        100,
        1200
      ],
      "id": "ecfc70ff-d7c2-436d-960c-307a46f64fbc",
      "name": "Postgres PGVector Store",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "wYLes21z9h3njdSn",
          "name": "postgress-prod"
        }
      }
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "query"
            },
            {
              "name": "for"
            },
            {
              "name": "threshold",
              "type": "number"
            },
            {
              "name": "book_number"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -440,
        1400
      ],
      "id": "ba334ad6-87c4-4514-a61d-d06c4f542cd2",
      "name": "Trigger"
    },
    {
      "parameters": {
        "mode": "load",
        "tableName": "=patchbay_embeddings",
        "prompt": "={{ $json.query }}",
        "options": {
          "distanceStrategy": "cosine",
          "metadata": {
            "metadataValues": [
              {
                "name": "for",
                "value": "={{ $json.for }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.1,
      "position": [
        100,
        1400
      ],
      "id": "a3914580-7f3f-45e7-9d04-6f09e0ae97e5",
      "name": "Postgres PGVector Store1",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "wYLes21z9h3njdSn",
          "name": "postgress-prod"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        220,
        1400
      ],
      "id": "0ec5b35b-037e-4d79-80fc-3640aba27fa7",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "mxdHDElSd4VQZiDt",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.for }}",
                    "rightValue": "master",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "33eb72b8-fee7-4bd0-a90a-3e748bb5326e"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "master"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "23c5c8d2-45da-4621-81f2-bfc92bf8aa4a",
                    "leftValue": "={{ ['persons', 'masters'] }}",
                    "rightValue": "={{ $json.for }}",
                    "operator": {
                      "type": "array",
                      "operation": "contains",
                      "rightType": "any"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "common"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7fdbf9a0-c8dd-4e58-af8c-ce999f7e92c2",
                    "leftValue": "={{ $json.for }}",
                    "rightValue": "artists",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "d7c26471-3134-4ef8-8313-abaead31c618",
                    "leftValue": "={{ $json.for }}",
                    "rightValue": "=organizations",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "organizations"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -300,
        1400
      ],
      "id": "0340f772-485f-405e-b96b-c10cc502551b",
      "name": "Switch"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0f12bc3d-9fab-4d4e-b4d7-6d27a6670dca",
              "name": "query",
              "value": "={{ $json.for === \"organizations\" ? \n  [\n    $json.query.organization_name && $json.query.organization_name.trim() ? `Organization Name: ${$json.query.organization_name}` : null,\n    $json.query.organization_role && $json.query.organization_role.trim() ? `Organization Role: ${$json.query.organization_role}` : null\n  ].filter(Boolean).join('\\n')\n  : \n  $json.query\n}}",
              "type": "string"
            },
            {
              "id": "d0619826-bf00-451e-9583-ce2c2811c804",
              "name": "organization_role",
              "value": "={{ $json.query.organization_role }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -40,
        1780
      ],
      "id": "66421635-f322-4277-8802-8916693d7cda",
      "name": "ORG INPUT"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0f12bc3d-9fab-4d4e-b4d7-6d27a6670dca",
              "name": "query",
              "value": "={{ $json.for === \"persons\" ? \n  [\n    $json.query.person_name && $json.query.person_name.trim() ? `Legal Name: ${$json.query.person_name}` : null,\n    $json.query.performer_name && $json.query.performer_name.trim() ? `Performer Name: ${$json.query.performer_name}` : null,\n    $json.query.role && $json.query.role.trim() ? `Role: ${$json.query.role}` : null\n  ].filter(Boolean).join('\\n')\n  : \n  $json.query\n}}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -40,
        1400
      ],
      "id": "85661c49-4428-40fd-8ce2-2b4e4370a645",
      "name": "OTHERS"
    },
    {
      "parameters": {
        "mode": "load",
        "tableName": "=organizations_vectorstore",
        "prompt": "={{ $json.query }}",
        "topK": 10,
        "options": {
          "distanceStrategy": "cosine",
          "metadata": {
            "metadataValues": [
              {
                "name": "organization_role",
                "value": "={{ $json.organization_role }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.1,
      "position": [
        140,
        1780
      ],
      "id": "c35cc78c-7e37-4348-b669-d2653949b622",
      "name": "Postgres PGVector Store2",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "wYLes21z9h3njdSn",
          "name": "postgress-prod"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the dynamic key from the Trigger node (e.g., \"persons\", \"artists\", etc.)\nconst trigger_input = $('Trigger').first().json;\nconst dynamicKey = trigger_input.for;\nconst query = trigger_input.query;\nconst threshold = trigger_input.threshold;\n\n// Format a nice message based on the query\nconst formatQueryMessage = (query, dynamicKey) => {\n  // Handle if query is a string\n  if (typeof query === 'string') {\n    return `\"${query}\"`;\n  }\n  \n  // Handle if query is an object\n  if (typeof query === 'object' && query !== null) {\n    if (dynamicKey === 'persons') {\n      const parts = [];\n      if (query.person_name?.trim()) {\n        parts.push(`Legal Name: \"${query.person_name}\"`);\n      }\n      if (query.performer_name?.trim()) {\n        parts.push(`Performer Name: \"${query.performer_name}\"`);\n      }\n      if (query.role?.trim()) {\n        parts.push(`Role: \"${query.role}\"`);\n      }\n      return parts.length > 0 ? parts.join(', ') : 'the provided criteria';\n    }\n    \n    // Fallback for other types (artists, masters, etc.)\n    return Object.entries(query)\n      .filter(([key, value]) => value && (typeof value !== 'string' || value.trim()))\n      .map(([key, value]) => `${key}: \"${value}\"`)\n      .join(', ') || 'the provided criteria';\n  }\n  \n  return 'the provided criteria';\n};\n\nconst queryMessage = formatQueryMessage(query, dynamicKey);\nconst items = $input.all();\n\n// If items array is empty or contains no json data, return a fallback\nif (!Array.isArray(items) || items.length === 0 || !items[0]?.json) {\n  return {\n    json: {\n      message: `I could not find any matching ${dynamicKey} for ${queryMessage} below the threshold of ${threshold}.\\n\\nThis ${dynamicKey.slice(0, -1)} does not exist in the Patchbay workspace.\\n\\nDon't call this tool again for the ${queryMessage}.`,\n      found: false,\n      query: query,\n      type: dynamicKey\n    }\n  };\n}\n\nconst scoredList = items\n  .map(item => {\n    const doc = item.json.document;\n    if (!doc || !doc.metadata || !doc.metadata.full_payload) return null;\n    \n    try {\n      // Parse the full_payload from metadata instead of pageContent\n      const parsedContent = JSON.parse(doc.metadata.full_payload);\n      parsedContent.score = item.json.score;\n      parsedContent.pairedItem = item.pairedItem?.item;\n      return parsedContent;\n    } catch (e) {\n      console.log('Parse error:', e.message);\n      return null;\n    }\n  })\n  .filter(entry => entry && entry.score <= threshold)\n  .sort((a, b) => a.score - b.score)\n  .slice(0, 3); // Get top 3 nearest matches\n\n// Return fallback if no entry matches score condition\nif (scoredList.length === 0) {\n  return {\n    json: {\n      message: `I could not find any matching ${dynamicKey} for ${queryMessage} below the threshold of ${threshold}.\\n\\nThis ${dynamicKey.slice(0, -1)} does not exist in the Patchbay workspace.\\n\\nDon't call this tool again for ${queryMessage}.`,\n      found: false,\n      query: query,\n      type: dynamicKey\n    }\n  };\n}\n\n// Build the message with match details\nlet message = `I found ${scoredList.length} nearest match${scoredList.length > 1 ? 'es' : ''} for ${dynamicKey} matching ${queryMessage}. Compare and analyze if it is the same ${dynamicKey.slice(0, -1)} you are referring to. If yes, extract the metadata for the match from below results:\\n\\n`;\n\nscoredList.forEach((match, index) => {\n  message += `-----------------\\n`;\n  message += `Match ${index + 1} (Score: ${match.score.toFixed(4)}):\\n`;\n  \n  // Format based on type\n  if (dynamicKey === 'persons') {\n    message += `Person Number: ${match.number || 'N/A'}\\n`;\n    message += `Legal Name: ${match.name || 'N/A'}\\n`;\n    message += `Performer Name: ${match.performer_name || 'N/A'}\\n`;\n    message += `Role: ${match.role || 'N/A'}\\n`;\n    message += `Person ID: ${match.id || 'N/A'}\\n`;\n  } else if (dynamicKey === 'artists') {\n    message += `Artist Number: ${match.number || 'N/A'}\\n`;\n    message += `Artist Name: ${match.name || 'N/A'}\\n`;\n    message += `Artist ID: ${match.id || 'N/A'}\\n`;\n  } else if (dynamicKey === 'masters') {\n    message += `Master Number: ${match.number || 'N/A'}\\n`;\n    message += `Master Name: ${match.name || 'N/A'}\\n`;\n    message += `Artist: ${match.artist_name || 'N/A'}\\n`;\n    message += `Master ID: ${match.id || 'N/A'}\\n`;\n  } else {\n    // Generic format for other types\n    Object.entries(match)\n      .filter(([key]) => key !== 'score' && key !== 'pairedItem')\n      .forEach(([key, value]) => {\n        message += `${key}: ${value || 'N/A'}\\n`;\n      });\n  }\n  \n  message += `-----------------\\n\\n`;\n});\n\nmessage += `Don't call this tool again for the same query again.`;\n\nreturn {\n  json: {\n    message: message,\n    found: true,\n    match_count: scoredList.length,\n    query: query,\n    type: dynamicKey,\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        1360
      ],
      "id": "e8a283f6-713a-4a04-b56d-65a1cb48af1e",
      "name": "search output"
    },
    {
      "parameters": {
        "jsCode": "const trigger = $('Trigger').first().json;\nconst searchResults = $input.all().flatMap(item => item.json); // Fixed: extract json from each item\n\nconst queryOrgName = trigger.query.organization_name;\nconst queryOrgRole = trigger.query.organization_role;\nconst threshold = trigger.threshold;\n\n// Filter results below threshold and sort by score (lower is better/nearer)\nconst matches = searchResults\n  .filter(item => item.score <= threshold)\n  .sort((a, b) => a.score - b.score)\n  .slice(0, 3); // Get top 3 nearest matches\n\nif (matches.length === 0) {\n  return {\n    json: {\n      message: `I could not find any matching organizations for \"${queryOrgName}\" with role \"${queryOrgRole}\" below the threshold of ${threshold}.\\n\\nThis organization does not exist in the Patchbay workspace. \\n\\nDon't call this tool again for the same.`,\n      found: false,\n      query: trigger.query\n    }\n  };\n}\n\n// Build the message with match details\nlet message = `I found ${matches.length} nearest match${matches.length > 1 ? 'es' : ''} for the organization \"${queryOrgName}\" as \"${queryOrgRole}\". Compare and analyze if it is the same organization you are referring to. If yes, extract the metadata for the match from below results:\\n\\n`;\n\nmatches.forEach((match, index) => {\n  const metadata = match.document.metadata;\n  message += `-----------------\\n`;\n  message += `Match ${index + 1} (Score: ${match.score.toFixed(4)}):\\n`;\n  message += `Organization Number: ${metadata.organization_number}\\n`;\n  message += `Organization Name: ${match.document.pageContent.split('\\n')[0].replace('Organization Name: ', '')}\\n`;\n  message += `Organization Role: ${metadata.organization_role}\\n`;\n  message += `Organization ID: ${metadata.organization_id}\\n`;\n  message += `-----------------\\n\\n`;\n});\n\nmessage += `Don't call this tool again for the same.`;\n\nreturn {\n  json: {\n    message: message,\n    found: true,\n    match_count: matches.length,\n    query: trigger.query,\n    matches: matches.map(m => ({\n      organization_number: m.document.metadata.organization_number,\n      organization_id: m.document.metadata.organization_id,\n      organization_role: m.document.metadata.organization_role,\n      organization_name: m.document.pageContent.split('\\n')[0].replace('Organization Name: ', ''),\n      score: m.score\n    }))\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        580,
        1780
      ],
      "id": "beac6923-f60b-416c-89ce-6b0e60c85fe5",
      "name": "org-output",
      "executeOnce": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0f12bc3d-9fab-4d4e-b4d7-6d27a6670dca",
              "name": "query",
              "value": "={{ $json.for === \"artists\" ? \n  [\n    $json.query.artist_name && $json.query.artist_name.trim() ? `Artist Name: ${$json.query.artist_name}` : null,\n  ].filter(Boolean).join('\\n')\n  : \n  $json.query\n}}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -60,
        1600
      ],
      "id": "dd53d89d-f673-4864-a2cb-3ecc6d4d7741",
      "name": "ART INPUT"
    },
    {
      "parameters": {
        "mode": "load",
        "tableName": "=artists_vectorstore",
        "prompt": "={{ $json.query }}",
        "topK": 10,
        "options": {
          "distanceStrategy": "cosine"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.1,
      "position": [
        100,
        1600
      ],
      "id": "ec7d106b-05c3-4b02-9f81-e9d86c4437d9",
      "name": "Postgres PGVector Store3",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "wYLes21z9h3njdSn",
          "name": "postgress-prod"
        }
      }
    }
  ],
  "pinData": {
    "Trigger": [
      {
        "json": {
          "query": {
            "organization_name": "1916 Enterprises 2.0 LLC",
            "organization_role": "Label"
          },
          "for": "organizations",
          "threshold": 0.7,
          "book_number": null
        }
      }
    ]
  },
  "repo_name": "hub-n8n",
  "repo_owner": "ck-bit",
  "repo_path": "",
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-10-17T17:11:19.613Z",
  "versionId": "7060a319-c4e2-49b6-9c92-e00bf8d49522"
}